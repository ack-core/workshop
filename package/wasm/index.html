<!DOCTYPE html>
<html>
<head>
    <link rel="icon" href="data:;base64,=">
    <style>
    .fullscreen {
        top: 5px;
        margin-left: auto;
        margin-right: auto;
        border: 0;
        width: 99%;
        height: height * 1.777;
        overflow: hidden;
        display: block;
    }
    </style>
</head>
<body>
    <canvas class="fullscreen" id="render_target" oncontextmenu="event.preventDefault()"></canvas>
    <script type='text/javascript'>
        class EventType {
            static INIT  = 1
            static READY = 2
            static BTASK = 3
            static FTASK = 4
        }

        var instance = {};
        var memory = new WebAssembly.Memory({ initial: 4, maximum: 1024, shared: true });
        var worker = new Worker("worker.js");
        var canvas = document.getElementById("render_target");
        var targetWidth = canvas.scrollWidth;
        var targetheight = canvas.scrollHeight;
        var prevFrameTimeStamp = 0;

        var glIDCounter = 0x10000000;
        var glshaders = {};
        var glcontext = canvas.getContext("webgl2");
        if (glcontext == null) {
            console.log("Failed to create GL Context");
        }

        const imports = {
            env: {
                memory: memory,
                js_waiting: () => console.log("[PLATFORM] waiting for memory lock"),
                js_log: function(str, len) {
                    const u16str = new Uint16Array(memory.buffer, str, len);
                    console.log(String.fromCharCode(...u16str));
                    instance.exports.__wrap_free(str);
                },
                js_task: function(task) {
                    worker.postMessage({type: EventType.BTASK, task});
                },
                js_fetch: function(block, pathLen) {
                    const u16path = new Uint16Array(memory.buffer, block, pathLen);
                    const path = String.fromCharCode(...u16path);
                    
                    fetch(path).then(response => {
                        if (response.ok) {
                            return response.arrayBuffer();
                        }
                        throw response.status + " " + response.statusText;
                    }).then(buffer => {
                        console.log(path + " loaded successfully");
                        const data = instance.exports.__wrap_malloc(buffer.byteLength);
                        const u8data = new Uint8Array(memory.buffer, data, buffer.byteLength);
                        u8data.set(new Uint8Array(buffer));
                        instance.exports.file(block, pathLen, data, buffer.byteLength);
                    }).catch(error => {
                        console.log(path + " loading failed with " + error);
                        instance.exports.file(block, pathLen, 0, 0);
                    });
                },
                js_canvas_width: () => targetWidth,
                js_canvas_height: () => targetHeight,
                abort: function() {
                    throw "aborted";
                },                
                webgl_makeProgram: function(vsrc, vlen, fsrc, flen) {
                    const vsstr = String.fromCharCode(...new Uint16Array(memory.buffer, vsrc, vlen));
                    const fsstr = String.fromCharCode(...new Uint16Array(memory.buffer, fsrc, flen));
                    instance.exports.__wrap_free(vsrc);
                    instance.exports.__wrap_free(fsrc);
                    
                    var vshader = glcontext.createShader(glcontext.VERTEX_SHADER);
                    var fshader = glcontext.createShader(glcontext.FRAGMENT_SHADER);
                    var program = glcontext.createProgram();

                    glcontext.shaderSource(vshader, vsstr);
                    glcontext.shaderSource(fshader, fsstr);
                    glcontext.compileShader(vshader);
                    glcontext.compileShader(fshader);

                    if (glcontext.getShaderParameter(vshader, glcontext.COMPILE_STATUS)) {
                        if (glcontext.getShaderParameter(fshader, glcontext.COMPILE_STATUS)) {
                            glcontext.attachShader(program, vshader);
                            glcontext.attachShader(program, fshader);
                            glcontext.linkProgram(program);
                            
                            if (glcontext.getProgramParameter(program, glcontext.LINK_STATUS)) {
                                glshaders[glIDCounter] = program;
                                return glIDCounter++;
                            }
                            else {
                                console.log("[WebGL link] " + glcontext.getProgramInfoLog(program));
                            }
                        }
                        else {
                            console.log("[WebGL fs] " + glcontext.getShaderInfoLog(fshader));
                        }
                    }
                    else {
                        console.log("[WebGL vs] " + glcontext.getShaderInfoLog(vshader));
                    }

                    glcontext.deleteShader(vshader);
                    glcontext.deleteShader(fshader);
                    glcontext.deleteProgram(program);

                    return 0;
                }
            }
        };

        WebAssembly.instantiateStreaming(fetch('workshop.wasm'), imports).then(m => {
            instance = m.instance;

            if (instance.exports.__wasm_call_ctors) {
                instance.exports.__wasm_call_ctors();
            }

            const module = m.module;
            worker.postMessage({type: EventType.INIT, module, memory});

            function onFrame(timestamp) {
                const interval = 1000.0 / 30.0;
                const dt = timestamp - prevFrameTimeStamp;
                
                if (dt > interval) {
                    prevFrameTimeStamp = timestamp;

                    instance.exports.frame(dt);

                    glcontext.viewport(0, 0, canvas.width, canvas.height);
                    glcontext.clearColor(1, 0, 0, 1);
                    glcontext.clear(glcontext.COLOR_BUFFER_BIT);
                }

                window.requestAnimationFrame(onFrame);
            }
            window.requestAnimationFrame(timestamp => {
                prevFrameTimeStamp = timestamp;
                window.requestAnimationFrame(onFrame);
            });
            window.addEventListener("resize", () => {
                targetWidth = canvas.scrollWidth;
                targetHeight = canvas.scrollHeight;
            });
        });

        worker.onmessage = (msg) => {
            if (msg.data.type == EventType.READY) {
                console.log("[PLATFORM] Background Thread started");
                instance.exports.initialize();
            }
            if (msg.data.type == EventType.FTASK) {
                instance.exports.task_complete(msg.data.task);
            }
        };
    </script>
</body>
</html>