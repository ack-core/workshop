<!DOCTYPE html>
<html>
<head>
    <link rel="icon" href="data:;base64,=">
    <style>
    .fullscreen {
        top: 5px;
        margin-left: auto;
        margin-right: auto;
        border: 0;
        width: 99%;
        height: height * 1.777;
        overflow: hidden;
        display: block;
    }
    </style>
</head>
<body>
    <canvas class="fullscreen" id="render_target" oncontextmenu="event.preventDefault()"></canvas>
    <script type='text/javascript'>
        const BUFFERS_REUSE_MAX = 256;
        const FRAME_CONST_BINDING_INDEX = 0;
        const DRAW_CONST_BINDING_INDEX = 1;
        const POINTER_DOWN = 1;
        const POINTER_MOVE = 2;
        const POINTER_UP = 3;
        const POINTER_CANCEL = 4;

        class EventType {
            static INIT  = 1
            static READY = 2
            static BTASK = 3
            static FTASK = 4
        }

        var instance = {};
        var memory = new WebAssembly.Memory({ initial: 4, maximum: 1024, shared: true });
        var worker = new Worker("worker.js");
        var canvas = document.getElementById("render_target");
        var targetWidth = window.devicePixelRatio * canvas.scrollWidth;
        var targetHeight = window.devicePixelRatio * canvas.scrollHeight;
        var activePointerIDs = {};
        var prevFrameTimeStamp = 0;
        var glShaderIDCounter = 0x10000000;
        var glBufferIDCounter = 0x20000000;
        var glshaders = {};
        var glbuffers = {};
        var glcontext = canvas.getContext("webgl2", { antialias: false });        
        var shaderConstantBuffers = [];
        var shaderConstantIndex = 0;
        var shaderVertexCountLocation = null;
        
        const imports = {
            env: {
                memory: memory,
                tanf: Math.tan,
                sinf: Math.sin,
                cosf: Math.cos,
                js_waiting: () => console.log("[PLATFORM] waiting for memory lock"),
                js_log: function(str, len) {
                    const u16str = new Uint16Array(memory.buffer, str, len);
                    console.log(String.fromCharCode(...u16str));
                },
                js_task: function(task) {
                    worker.postMessage({type: EventType.BTASK, task});
                },
                js_fetch: function(block, pathLen) {
                    const u16path = new Uint16Array(memory.buffer, block, pathLen);
                    const path = String.fromCharCode(...u16path);
                    
                    fetch(path).then(response => {
                        if (response.ok) {
                            return response.arrayBuffer();
                        }
                        throw response.status + " " + response.statusText;
                    }).then(buffer => {
                        console.log(path + " loaded successfully");
                        const data = instance.exports.__wrap_malloc(buffer.byteLength);
                        const u8data = new Uint8Array(memory.buffer, data, buffer.byteLength);
                        u8data.set(new Uint8Array(buffer));
                        instance.exports.fileLoaded(block, pathLen, data, buffer.byteLength);
                    }).catch(error => {
                        console.log(path + " loading failed with " + error);
                        instance.exports.fileLoaded(block, pathLen, 0, 0);
                    });
                },
                js_canvas_width: () => targetWidth,
                js_canvas_height: () => targetHeight,
                abort: function() {
                    throw "aborted";
                },
                webgl_createProgram: function(vsrc, vlen, fsrc, flen) {
                    const vsstr = String.fromCharCode(...new Uint16Array(memory.buffer, vsrc, vlen));
                    const fsstr = String.fromCharCode(...new Uint16Array(memory.buffer, fsrc, flen));
                    
                    var vshader = glcontext.createShader(glcontext.VERTEX_SHADER);
                    var fshader = glcontext.createShader(glcontext.FRAGMENT_SHADER);
                    var program = glcontext.createProgram();

                    glcontext.shaderSource(vshader, vsstr);
                    glcontext.shaderSource(fshader, fsstr);
                    glcontext.compileShader(vshader);
                    glcontext.compileShader(fshader);

                    if (glcontext.getShaderParameter(vshader, glcontext.COMPILE_STATUS)) {                        
                        if (glcontext.getShaderParameter(fshader, glcontext.COMPILE_STATUS)) {
                            glcontext.attachShader(program, vshader);
                            glcontext.attachShader(program, fshader);
                            glcontext.linkProgram(program);
                            glcontext.validateProgram(program);
                            glcontext.uniformBlockBinding(program, glcontext.getUniformBlockIndex(program, "_FrameData"), FRAME_CONST_BINDING_INDEX);

                            const cIndex = glcontext.getUniformBlockIndex(program, "_Constants");
                            if (cIndex != 0xFFFFFFFF) {
                                glcontext.uniformBlockBinding(program, glcontext.getUniformBlockIndex(program, "_Constants"), DRAW_CONST_BINDING_INDEX);
                            }
                            if (glcontext.getProgramParameter(program, glcontext.LINK_STATUS)) {
                                glcontext.deleteShader(vshader);
                                glcontext.deleteShader(fshader);
                                glshaders[glShaderIDCounter] = program;
                                return glShaderIDCounter++;
                            }
                            else {
                                console.log("[WebGL link] " + glcontext.getProgramInfoLog(program));
                            }
                        }
                        else {
                            console.log("[WebGL fs] " + glcontext.getShaderInfoLog(fshader));
                        }
                    }
                    else {
                        console.log("[WebGL vs] " + glcontext.getShaderInfoLog(vshader));
                    }

                    glcontext.deleteShader(vshader);
                    glcontext.deleteShader(fshader);
                    glcontext.deleteProgram(program);

                    return 0;
                },
                webgl_createData: function(layout, layoutLen, ptr, dataLen) {
                    const u8mem = new Uint8Array(memory.buffer, ptr, dataLen);
                    const lmem = new Uint8Array(memory.buffer, layout, layoutLen);
                    const vbo = glcontext.createBuffer();
                    
                    glcontext.bindBuffer(glcontext.ARRAY_BUFFER, vbo);
                    glcontext.bufferData(glcontext.ARRAY_BUFFER, u8mem, glcontext.STATIC_DRAW);
                    glbuffers[glBufferIDCounter] = vbo;
                    return glBufferIDCounter++;
                },
                webgl_applyState: function(shaderID) {
                    glcontext.clearColor(0.1, 0.1, 0.1, 1);
                    glcontext.clear(glcontext.COLOR_BUFFER_BIT);

                    const shader = glshaders[shaderID]
                    glcontext.useProgram(shader);
                    shaderVertexCountLocation = glcontext.getUniformLocation(shader, "_vertex_count");
                },
                webgl_applyConstants: function(index, ptr, len) {
                    const u8mem = new Uint8Array(memory.buffer, ptr, len);
                    glcontext.bindBuffer(glcontext.UNIFORM_BUFFER, shaderConstantBuffers[shaderConstantIndex]);
                    glcontext.bufferData(glcontext.UNIFORM_BUFFER, u8mem, glcontext.DYNAMIC_DRAW);
                    glcontext.bindBufferBase(glcontext.UNIFORM_BUFFER, index, shaderConstantBuffers[shaderConstantIndex]);
                    shaderConstantIndex = (shaderConstantIndex + 1) % BUFFERS_REUSE_MAX;
                },
                webgl_bindBuffer: function(bufferID) {
                    glcontext.bindBuffer(glcontext.ARRAY_BUFFER, glbuffers[bufferID]);
                },
                webgl_vertexAttribute: function(index, size, type, nrm, stride, offset, divisor) {
                    glcontext.enableVertexAttribArray(index);
                    glcontext.vertexAttribPointer(index, size, type, nrm, stride, offset);
                    glcontext.vertexAttribDivisor(index, divisor);
                },
                webgl_draw: function(vertexCount, topology) {
                    glcontext.uniform1i(shaderVertexCountLocation, vertexCount);
                    glcontext.drawArrays(topology, 0, vertexCount);
                },
                webgl_drawInstanced: function(vertexCount, instanceCount, topology) {
                    glcontext.uniform1i(shaderVertexCountLocation, vertexCount);
                    glcontext.drawArraysInstanced(topology, 0, vertexCount, instanceCount);
                }
            }
        };

        if (glcontext != null) {
            WebAssembly.instantiateStreaming(fetch('workshop.wasm'), imports).then(m => {
                instance = m.instance;

                if (instance.exports.__wasm_call_ctors) {
                    instance.exports.__wasm_call_ctors();
                }

                const module = m.module;
                worker.postMessage({type: EventType.INIT, module, memory});

                window.addEventListener("resize", () => {
                    targetWidth = window.devicePixelRatio * canvas.scrollWidth;
                    targetHeight = window.devicePixelRatio * canvas.scrollHeight;
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                });
            });
        }
        else {
            console.log("Failed to create GL Context");
        }

        worker.onmessage = (msg) => {
            if (msg.data.type == EventType.READY) {
                console.log("[PLATFORM] Background Thread started");
                canvas.width = targetWidth;
                canvas.height = targetHeight;

                for (var i = 0; i < BUFFERS_REUSE_MAX; i++) {
                    shaderConstantBuffers[i] = glcontext.createBuffer();
                }
                
                glbuffers[0] = glcontext.createBuffer();
                glcontext.bindVertexArray(glcontext.createVertexArray());
                glcontext.enableVertexAttribArray(0);

                instance.exports.initialize();

                function getCoord(event) {
                    const rect = canvas.getBoundingClientRect();
                    const x = (event.clientX - rect.left) * window.devicePixelRatio;
                    const y = (event.clientY - rect.top) * window.devicePixelRatio;
                    return [x, y];
                }
                function onFrame(timestamp) {
                    const interval = 1000.0 / 30.0;
                    const dt = timestamp - prevFrameTimeStamp;
                    
                    if (dt > interval) {
                        prevFrameTimeStamp = timestamp;
                        glcontext.viewport(0, 0, canvas.width, canvas.height);
                        instance.exports.updateFrame(dt);
                    }

                    window.requestAnimationFrame(onFrame);
                }
                window.requestAnimationFrame(timestamp => {
                    prevFrameTimeStamp = timestamp;
                    window.requestAnimationFrame(onFrame);
                });
                window.addEventListener("pointerdown", (event) => {
                    [x, y] = getCoord(event);
                    if (x >= 0 && y >= 0 && x <= targetWidth && y <= targetHeight) {
                        activePointerIDs[event.pointerId] = true;
                        instance.exports.pointerEvent(POINTER_DOWN, event.pointerId, x, y);
                    }
                });
                window.addEventListener("pointermove", (event) => {
                    if (activePointerIDs[event.pointerId]) {
                        [x, y] = getCoord(event);
                        instance.exports.pointerEvent(POINTER_MOVE, event.pointerId, x, y);
                    }
                });
                window.addEventListener("pointerup", (event) => {
                    if (activePointerIDs[event.pointerId]) {
                        delete activePointerIDs[event.pointerId];
                        [x, y] = getCoord(event);
                        instance.exports.pointerEvent(POINTER_UP, event.pointerId, x, y);
                    }
                });
                window.addEventListener("pointercancel", (event) => {
                    if (activePointerIDs[event.pointerId]) {
                        delete activePointerIDs[event.pointerId];
                        [x, y] = getCoord(event);
                        instance.exports.pointerEvent(POINTER_CANCEL, event.pointerId, x, y);
                    }
                });                
            }
            if (msg.data.type == EventType.FTASK) {
                instance.exports.taskComplete(msg.data.task);
            }
        };
    </script>
</body>
</html>
