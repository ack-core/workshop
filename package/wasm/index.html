<!DOCTYPE html>
<html>
<head>
    <link rel="icon" href="data:;base64,=">
    <style>
    .fullscreen {
        top: 5px;
        margin-left: auto;
        margin-right: auto;
        border: 0;
        width: 99%;
        height: height * 1.777;
        overflow: hidden;
        display: block;
    }
    </style>
</head>
<body>
    <canvas class="fullscreen" id="render_target" oncontextmenu="event.preventDefault()"></canvas>
    <script type='text/javascript'>
        class EventType {
            static INIT  = 1
            static READY = 2
            static BTASK = 3
            static FTASK = 4
        }

        var instance = {};
        var memory = new WebAssembly.Memory({ initial: 4, maximum: 1024, shared: true });
        var worker = new Worker("worker.js");
        var canvas = document.getElementById("render_target");
        var target_width = canvas.scrollWidth;
        var target_height = canvas.scrollHeight;

        var glcontext = canvas.getContext("webgl2");
        if (glcontext == null) {
            console.log("Failed to create GL Context");
        }

        var prevFrameTimeStamp = 0;

        const imports = {
            env: {
                memory: memory,
                abort: function() {
                    throw "aborted";
                },
                js_waiting: () => console.log("[PLATFORM] waiting for memory lock"),
                js_log: function(str, len) {
                    const u16str = new Uint16Array(memory.buffer, str, len);
                    console.log(String.fromCharCode(...u16str));
                    instance.exports.__wrap_free(str);
                },
                js_task: function(task) {
                    worker.postMessage({type: EventType.BTASK, task});
                },
                js_fetch: function(block, pathLen) {
                    const u16path = new Uint16Array(memory.buffer, block, pathLen);
                    const path = String.fromCharCode(...u16path);
                    
                    fetch(path).then(response => {
                        if (response.ok) {
                            return response.arrayBuffer();
                        }
                        throw response.status + " " + response.statusText;
                    }).then(buffer => {
                        console.log(path + " loaded successfully");
                        const data = instance.exports.__wrap_malloc(buffer.byteLength);
                        const u8data = new Uint8Array(memory.buffer, data, buffer.byteLength);
                        u8data.set(new Uint8Array(buffer));
                        instance.exports.file(block, pathLen, data, buffer.byteLength);
                    }).catch(error => {
                        console.log(path + " loading failed with " + error);
                        instance.exports.file(block, pathLen, 0, 0);
                    });
                },
                js_canvas_width: () => target_width,
                js_canvas_height: () => target_height
            }
        };

        WebAssembly.instantiateStreaming(fetch('workshop.wasm'), imports).then(m => {
            instance = m.instance;

            if (instance.exports.__wasm_call_ctors) {
                instance.exports.__wasm_call_ctors();
            }

            const module = m.module;
            worker.postMessage({type: EventType.INIT, module, memory});

            function onFrame(timestamp) {
                const interval = 1000.0 / 30.0;
                const dt = timestamp - prevFrameTimeStamp;
                
                if (dt > interval) {
                    prevFrameTimeStamp = timestamp;

                    instance.exports.frame(dt);

                    glcontext.viewport(0, 0, canvas.width, canvas.height);
                    glcontext.clearColor(1, 0, 0, 1);
                    glcontext.clear(glcontext.COLOR_BUFFER_BIT);
                }

                window.requestAnimationFrame(onFrame);
            }
            window.requestAnimationFrame(timestamp => {
                prevFrameTimeStamp = timestamp;
                window.requestAnimationFrame(onFrame);
            });
            window.addEventListener("resize", () => {
                target_width = canvas.scrollWidth;
                target_height = canvas.scrollHeight;
            });
        });

        worker.onmessage = (msg) => {
            if (msg.data.type == EventType.READY) {
                console.log("[PLATFORM] Background Thread started");
                instance.exports.initialize();
            }
            if (msg.data.type == EventType.FTASK) {
                instance.exports.task_complete(msg.data.task);
            }
        };
    </script>
</body>
</html>