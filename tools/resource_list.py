from __future__ import annotations

"""
Tool to make engine resources list (*.vox, *.plc)
"""

import typing
import argparse
import os
import struct

PNG_READ_LENGTH = 26
PNG_SIGN = b'\x89PNG\r\n\x1a\n'
PNG_REQUIRED_DEPTH = 8
PNG_COLOR_TYPE_GRAYSCALE = 0
PNG_COLOR_TYPE_RGBA = 6

VOX_READ_MAIN = 20
VOX_READ_CHUNK_HEADER = 4

GRD_READ_HEADER = 16

def list_png(root: str, file: str, out: typing.BinaryIO) -> None:
    fullpath = os.path.join(root, file)
    with open(fullpath, mode="rb") as f:
        header = f.read(PNG_READ_LENGTH)
        try:
            sign, _, _, w, h, depth, color_type = struct.unpack(">8siiiiBB", header)
            if sign == PNG_SIGN and depth == PNG_REQUIRED_DEPTH:
                color_types = {
                    PNG_COLOR_TYPE_GRAYSCALE: "foundation::RenderTextureFormat::R8UN",
                    PNG_COLOR_TYPE_RGBA: "foundation::RenderTextureFormat::RGBA8UN"
                }

                if color_type in color_types:
                    file = file.replace(".png", "")
                    msg = "        {{ \"{}\", {{ {}, {}, {} }}}},\r\n".format(file, w, h, color_types[color_type])
                    out.write(msg.encode("utf-8"))

        except (Exception,) as e:
            print("---- Error: '{}' caused '{}'".format(fullpath, e))
            pass

def list_vox(root: str, file: str, out: typing.BinaryIO) -> None:
    fullpath = os.path.join(root, file)
    file = file.replace(".vox", "")

    with open(fullpath, mode="rb") as f:
        header = f.read(VOX_READ_MAIN)
        version = struct.unpack("<i", header[4:8])[0]
        frame_count = 1

        if version == 0x96:
            current_offset = f.tell()
            if f.read(VOX_READ_CHUNK_HEADER) == b'PACK':
                data = f.read(12)
                frame_count = struct.unpack("<i", data[8:12])[0]
            else:
                f.seek(current_offset)

            mx, my, mz = (0, 0, 0)

            for i in range(0, frame_count):
                if f.read(VOX_READ_CHUNK_HEADER) == b'SIZE':
                    data = f.read(20)
                    sz, sx, sy = struct.unpack("<iii", data[8:20])

                    mx = sx if sx > mx else mx
                    my = sy if sy > my else my
                    mz = sz if sz > mz else mz

                    if f.read(VOX_READ_CHUNK_HEADER) == b'XYZI':
                        data = f.read(12)
                        voxel_count = struct.unpack("<i", data[8:])[0]
                        f.read(voxel_count * 4)
                    else:
                        print("---- Error: '{}' has no 'XYZI' block".format(fullpath))
                        return
                else:
                    print("---- Error: '{}' has no 'SIZE' block".format(fullpath))
                    return

            msg = "        {{\"{}\", {{ {}, {}, {} }}}},\r\n".format(file, mx, my, mz)
            out.write(msg.encode("utf-8"))

        elif version == 0x7f:
            data = f.read(12)
            sx, sy, sz = struct.unpack("<iii", data)
            msg = "        {{\"{}\", {{ {}, {}, {} }}}},\r\n".format(file, sx, sy, sz)
            out.write(msg.encode("utf-8"))

        else:
            print("---- Error: '{}' has unknown format".format(fullpath))

def list_grd(root: str, file: str, out: typing.BinaryIO) -> None:
    fullpath = os.path.join(root, file)
    file = file.replace(".grd", "")

    with open(fullpath, mode="rb") as f:
        f.read(GRD_READ_HEADER)
        data = f.read(12)
        sx, sy, sz = struct.unpack("<iii", data)
        msg = "        {{\"{}\", {{ {}, {}, {} }}}},\r\n".format(file, sx, sy, sz)
        out.write(msg.encode("utf-8"))
        pass

def main(root: str, dst: str) -> None:
    type_items: dict[str, tuple[callable, str, str, str]] = {
        ".vox": (
            list_vox,
            "    const std::unordered_map<const char *, MeshInfo> MESHES_LIST = {\r\n",
            "#include \"resource_provider.h\"\r\n\r\n",
            "meshes_list.h"
        ),
        ".png": (
            list_png,
            "    const std::unordered_map<const char *, TextureInfo> TEXTURES_LIST = {\r\n",
            "#include \"resource_provider.h\"\r\n\r\n",
            "textures_list.h"
        ),
        ".grd": (
            list_grd,
            "    const std::unordered_map<const char *, GroundInfo> GROUNDS_LIST = {\r\n",
            "#include \"resource_provider.h\"\r\n\r\n",
            "grounds_list.h"
        )
    }

    root = os.path.abspath(root)
    dst = os.path.abspath(dst)

    for ext, type_item in type_items.items():
        with open(os.path.join(dst, type_item[3]), mode="wb") as f:
            f.write("// this file is generated by resource_list.py\r\n".encode("utf-8"))
            f.write("#include <unordered_map>\r\n".encode("utf-8"))
            f.write(type_item[2].encode("utf-8"))
            f.write("namespace resource {\r\n".encode("utf-8"))
            f.write(type_item[1].encode("utf-8"))

            for path, _, files in os.walk(root):
                for file in files:
                    if file.endswith(ext):
                        relpath = os.path.relpath(path, root)
                        if not relpath.startswith("."):
                            type_item[0](root, os.path.join(relpath, file), f)

            f.write("    };\r\n".encode("utf-8"))
            f.write("}\r\n".encode("utf-8"))

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Tool to form list of resources")
    parser.add_argument("-r", "--root", type=str, required=True, help="Path where to search resources")
    parser.add_argument("-d", "--dst", type=str, required=True, help="Folder to write generated output")
    args = parser.parse_args()
    main(**vars(args))
